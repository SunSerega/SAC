

%EnterName						=Введите имя оператор чтоб получить его описание, или пустую строку для списка операторов

H|Key							=Нажимает/отжимает кнопку на клавиатуре
T|Key							=\
	Key 65 0\
	Ничего не сделает\
	\
	Key 65 1\
	Нажмёт латинскую "A" на клавиатуре, и оставит её нажатой\
	\
	Key 65 2\
	Отожмёт латинскую "A" на клавиатуре\
	\
	Key 65 3\
	Нажмёт и затем отожмёт латинскую "A" на клавиатуре\
	\
	Обратите внимание, последний операнд этого оператора смотрит только на последние 2 бита\
	Поэтому 10(0x1010) будет работать как 2(0x0010), и т.д.\
	\
	Вы можете узнать код кнопки, запустив WK.exe и нажав нужную кнопку

H|KeyD							=Нажимает кнопку на клавиатуре
T|KeyD							=\
	KeyD 65\
	Нажмёт латинскую "A" на клавиатуре, и оставит её нажатой\
	\
	Вы можете узнать код кнопки, запустив WK.exe и нажав нужную кнопку

H|KeyU							=Отжимает кнопку на клавиатуре
T|KeyU							=\
	KeyU 65\
	Отожмёт латинскую "A" на клавиатуре\
	\
	Вы можете узнать код кнопки, запустив WK.exe и нажав нужную кнопку

H|KeyP							=Нажимает и затем отжимает кнопку на клавиатуре
T|KeyP							=KeyP 65\
	Нажмёт и затем отожмёт латинскую "A" на клавиатуре\
	\
	Вы можете узнать код кнопки, запустив WK.exe и нажав нужную кнопку

%1=





H|Mouse							=Нажимает/отжимает кнопку мышки
T|Mouse							=\
	Mouse 2 0\
	Ничего не сделает\
	\
	Mouse 2 1\
	Нажмёт ПКМ, и оставит её нажатой\
	\
	Mouse 2 2\
	Отожмёт ПКМ\
	\
	Mouse 2 3\
	Нажмёт и затем отожмёт ПКМ\
	\
	Обратите внимание, последний операнд этого оператора смотрит только на последние 2 бита\
	Поэтому 10(0x1010) будет работать как 2(0x0010), и т.д.\
	\
	Коды кнопок мыши:\
	1: ЛКМ\
	2: ПКМ\
	4: СКМ\
	5: Боковая кнопка1\
	6: Боковая кнопка2

H|MouseD						=Нажимает кнопку мышки
T|MouseD						=\
MouseD 2\
	Нажмёт ПКМ, и оставит её нажатой\
	\
	Коды кнопок мыши:\
	Коды кнопок мыши:\
	1: ЛКМ\
	2: ПКМ\
	4: СКМ\
	5: Боковая кнопка1\
	6: Боковая кнопка2

H|MouseU						=Отжимает кнопку мышки
T|MouseU						=\
	MouseU 2\
	Отожмёт ПКМ\
	\
	Коды кнопок мыши:\
	Коды кнопок мыши:\
	1: ЛКМ\
	2: ПКМ\
	4: СКМ\
	5: Боковая кнопка1\
	6: Боковая кнопка2

H|MouseP						=Нажимает и затем отжимает кнопку мышки
T|MouseP						=\
	MouseP 2\
	Нажмёт и затем отожмёт ПКМ\
	\
	Коды кнопок мыши:\
	Коды кнопок мыши:\
	1: ЛКМ\
	2: ПКМ\
	4: СКМ\
	5: Боковая кнопка1\
	6: Боковая кнопка2

%2=





H|MousePos						=Передвигает мышку к указанным координатам
T|MousePos						=\
	MousePos 123 456\
	Передвинет мышку на координаты (123; 456), считая с левого верхнего угла

H|GetKey						=Узнаёт нажата ли кнопка
T|GetKey						=\
	GetKey 65 KeyA\
	Запишет 1 (латинское "A" нажато) или 0 (латинское "A" отжато) в переменной "KeyA"\
	\
	Вы можете узнать код кнопки, запустив WK.exe и нажав нужную кнопку

H|GetKeyTrigger					=Узнаёт активирован ли триггер кнопки (как у CapsLock)
T|GetKeyTrigger					=\
	GetKeyTrigger 20 CapsLockKey\
	Сохранит 1 (CapsLock включён) или 0 (CapsLock выключен) в переменной "CapsLockKey"\
	\
	Вы можете узнать код кнопки, запустив WK.exe и нажав нужную кнопку

H|GetMousePos					=Получает позицию курсора
T|GetMousePos					=\
	GetMousePos MouseX MouseY\
	Запишет позицию курсора в "MouseX" и "MouseY", считая с левого верхнего угла

%3=





H|Jump							=Переставляет точку выполнения к указаной метке
T|Jump							=\
	Jump "#lable1"\
	Найдет метку "lable1" в данном файле и продолжит выполнение с неё\
	\
	Jump "file1.sac"\
	Найдёт файл "file1.sac" и выполнит его, вместо текущего\
	\
	Jump "file2.sac#lable2"\
	Найдёт метку "lable2" в файле "file2.sac" и продолжит выполнение с неё\
	\
	Jump null\
	Сработает как Return, потому что это прыжок в никуда\
	(В основном используется в JumpIf)

H|JumpIf						=Переставляет точку выполнения к 1 из 2 указаных меток
T|JumpIf						=\
	JumpIf n < 5 #lable1 null\
	Если n меньше чем 5 - будет выполнено Jump "#lable1"\
	Иначе будет выполнено Jump null\
	\
	В качестве символа сравнения можно использовать только ">", "<" или "="

%4=





H|Call							=Переставляет точку выполнения к указаной метке, сохраняя текущую позицию
T|Call							=\
	Call exec_point_name\
	Работает так же как Jump, но сохраняет текущую позицию\
	Когда будет выполнен Return или достигнут конец файла - будет загружена последняя сохранённая позиция\
	Вы можете сохранять несколько позиций друг за другому,\
	это позволяет делать рекурсивные алгоритмы\
	\
	Call null\
	Будет проигнорировано, потому что оно сохраняет позицию и сразу загружает её назад\
	(Jump null работает как Return)

H|CallIf						=Переставляет точку выполнения к 1 из 2 указаных меток, сохраняя текущую позицию
T|CallIf						=\
	CallIf n < 5 #lable1 null\
	Если n меньше чем 5 - будет выполнено Call "#lable1"\
	Иначе будет выполнено Call null\
	\
	В качестве символа сравнения можно использовать только ">", "<" или "="

%5=





H|Susp							=Приостанавливает выполнение и ожидает нажатия кнопки(-ок) возобновления
T|Susp							=\
	Susp\
	Приостановит выполнение и будет ждать нажатия кнопки(-ок) возобновления\
	Вы можете выбрать кнопки возобновления, нажав "Уст. кнопку" когда скрипт загружен

H|Return						=Работает как конец файла
T|Return						=\
	Return\
	Вернёться к последнему вызову оператора Call/CallIf\
	Если их не было - выполнит Halt\
	\
	То же самое происходит в конце файла

H|Halt							=Останавливает скрипт
T|Halt							=\
	Halt\
	Вызовет немедленное завершение работы SAC.exe

%6=





H|Sleep							=Ждёт указанное кол-во миллисекунд
T|Sleep							=\
	Sleep 500\
	Подождёт пол секунды, перед тем как продолжить выполняться

H|Random						=Генерирует псевдо-случайное число
T|Random						=\
	Random r\
	Сгенерирует псевдо-случайное число в диапазоне [0,1) и сохранит в переменной "r"

H|Output						=Выписывает значение в вывод
T|Output						=\
	Output 5+3\
	Выпишет "8" в стандартный вывод




